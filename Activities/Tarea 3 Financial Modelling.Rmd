---
title: "Tarea 3 Financial Modelling"
author: "Raymundo Díaz"
date: "7/10/2021"
output: html_document
---
---
title: "Algorithmic trading applied to portfolio management"
output:
  html_document: default
  word_document: default
---

# Algorithmic trading applied to portfolio management


Momentum in stock returns is generally described as the continuation of those stocks that have performed well recently to do well over the subsequent 1–12 months. On the contrary, long-term reversals refer to the pattern of winning (loser) stocks tending to become losers (winners) in the long run, usually 3–5 years.
 
 In general, momentum and reversals in stock prices is evaluated by sorting stocks into portfolios based on their past return performance and then evaluating the future performance of these portfolios. Although the process of forming winner and loser portfolios to assess momentum and reversals in stock prices is fairly standardized in the literature, the decisions of how to construct the winner and loser portfolios (equally weighted vs. value-weighted) and how to measure risk-adjusted return performance (CAPM, Fama-French 3-factor risk models) remain topics of debate.
 
 A momentum (reversal) portfolio is then created by buying (shorting) the winner portfolio and shorting (buying) the loser portfolio and then evaluating the performance of this zero-cost, long-short portfolio over the next K months. 
 
 So, for example, a 6/6 momentum strategy is a momentum strategy that sorts stocks based on their past 6-month returns and creates a long-short portfolio by buying the winner portfolio and shorting the loser portfolio (as defined earlier) and holding the position for 6 months.


```{r include=FALSE}
library(quantmod)
library(xml2)
library(rvest)
library(openxlsx)
library(readxl)
```


For this example, we could use the Excel file or 
```{r warning=FALSE}
df<- read_excel("C:/Users/Magaly/Desktop/RAY/21 UNIVERSIDADES/ITESM MTY AGO DIC 21/Modelacion y Programacion Financiera/Tarea 3 tickers 11 nov 21.xlsx")
```

The Api to download the tickers from yahoo finance
```{r}
yf <- "https://finance.yahoo.com/quote/%5EBBY/components?p=%5EBBY"

html <- read_html(yf)

# To get the node a, wich contains characters 
node <- html_nodes(html,"a")

# To read the text in the node
node<-html_text(node, trim=TRUE)

# To get the elements that have USD (the tickers). For the IPC tickers, replace "USD" with ".MX". For other tickers, print the node object and look for patterns or select by rows. 
tickers<-grep(pattern = ".USD", x = node, value = TRUE)

#to eliminate tickers whiout information
tickers<-tickers
tickers<-tickers[-27]
tickers<-tickers[-27]
tickers<-tickers[-27]
tickers<-tickers[-26]
tickers<-tickers[-26]
tickers
```

This code gets the current IPC tickers from yahoo finance. The stock composition could change over time, them if you want to replicate the example of this document, in the file data.xlsx you will find the sample close prices. T his code gets the current IPC tickers from yahoo finance. The stock composition could change over time, them if you want to replicate the example of this document,  you will find the sample close prices.

```{r}
tickers<-colnames(df)
tickers<-tickers[-1]

```



```{r include=FALSE}
getSymbols(tickers, from="2020-01-01",to="2021-11-15")
n<-length(tickers)
df<-get(tickers[1])[,6]

# loop
for (i in 2:n){
df2<-get(tickers[i])[,6]
df<-cbind(df,df2)
}
df
```

This code gets the 1st and the 3rd tranches in one object. Also, it gets the daily returns for each stock, which we use to estimate the covariance matrix.

```{r}
ret <-diff(log(df)) # matriz de rendimiento
reta<-apply(ret,2,mean,na.rm=T) # rend promedio arith
reta<-data.frame(reta)
```

```{r}
sd <- sd(df[,1],na.rm = T)


```

Sort
```{r include=FALSE}
library(dplyr)

reta1<-reta %>% arrange(desc(reta))

detach("package:dplyr", unload=TRUE)
```


```{r}
m<-dim(reta1)[1] # numero de tickers
n<-round(m/3) # tamaño de la muestra de cada tranche
reta1L<-data.frame(reta1[1:n,]) 
reta1S<-data.frame(reta1[(m-n):m,])
rownames(reta1L)<-rownames(reta1)[1:n]
rownames(reta1S)<-rownames(reta1)[(m-n):m]
```

```{r}
colnames(reta1L)<-"ret"
colnames(reta1S)<-"ret"
reta1LS<-data.frame(rbind(reta1L,reta1S))

```
# Para hacer la partición 

#retL2 <- reta1 %>% top_frac(0.33)
#ret2S <- reta1 %>% top_frac(-0.68)

```{r}
ret2<- ret[,rownames(reta1LS)]
cov<-cov(ret2,use="complete.obs")


weL<-  runif(n, 0, 1)
s<-sum(weL)
weL<-(weL/s)*1.1

weS<-  runif((m-n):m, 0, 1)
sS<-sum(weS)
weS<-(-weS/sS)*.1
#weL# vector de pesos aleatotios
# cov%*%we 
#para generar aleatorios runif(le1, 0, 1)
weLS<-data.frame(c(weL,weS))
rownames(weLS)<-rownames(reta1LS)
colnames(weLS)<-"weLS"
weLS
```

la desv del portafolio
```{r}
covm<-as.matrix(cov)
weLSm<-as.matrix(weLS)
covt<-covm%*%weLSm
covLS<-((t(weLSm)%*%covt)*252)^.5 # desv anualizada
covLS    # desv mult
```

```{r}
reta1LSm<-as.matrix(reta1LS)
reta1LSf<-(t(weLSm)%*%reta1LSm)*252 #rend esperado del 
reta1LSf
# num simulaciones que se quiere realizar
sim<-10
# número de tickers del portafolio
nt<-length(rownames(reta1LS))
#Matriz para almacenar los resultados del loop
port<-matrix(0,sim,3+nt)
port[1,1]<-reta1LSf # rend esp por
port[1,2]<-covLS # las desv est del por 
sharpe<-(reta1LSf-.05)/covLS # rf=.05  
port[1,3]<-sharpe # antes decía covLS
port[1,4:(3+nt)]<-weLSm[,1]
colnames(port)<-c("rend","desv_est","sharpe",rownames(reta1LS))
```


Copie y pegué desde weL<-  runif(n, 0, 1) hasta mi rengñon 167 en un solo chunk
```{r}
sim<-2000
nt<-length(rownames(reta1LS))
#Matriz para almacenar los resultados del loop
port<-matrix(0,sim,3+nt)

for (i in 1:sim){
   
weL<-  runif(n, 0, 1)
s<-sum(weL)
weL<-(weL/s)*1.1
weS<-  runif((m-n):m, 0, 1)
sS<-sum(weS)
weS<-(-weS/sS)*.1
weLS<-data.frame(c(weL,weS))
rownames(weLS)<-rownames(reta1LS)
colnames(weLS)<-"weLS"
#covm<-as.matrix(cov)
weLSm<-as.matrix(weLS)
covt<-covm%*%weLSm
covLS<-((t(weLSm)%*%covt)*252)^.5 # desv anualizada
reta1LSm<-as.matrix(reta1LS)
reta1LSf<-(t(weLSm)%*%reta1LSm)*252 #rend eserado 
# num simulaciones que se quiere realizar
port[i,1]<-reta1LSf
port[i,2]<-covLS  
sharpe<-(reta1LSf-.05)/covLS  
port[i,3]<-sharpe
port[i,4:(3+nt)]<-weLSm[,1]
}
colnames(port)<-c("rend","desv_est","sharpe",rownames(reta1LS))
```

```{r}
plot(port[,2],port[,1])
```

```{r}
for (i in 2:sim)
   {
weL<-  runif(n, 0, 1)
s<-sum(weL)
weL<-(weL/s)*1.1
weS<-  runif((m-n):m, 0, 1)
sS<-sum(weS)
weS<-(-weS/sS)*.1
weLS<-data.frame(c(weL,weS))
rownames(weLS)<-rownames(reta1LS)
colnames(weLS)<-"weLS"
weLSm<-as.matrix(weLS)
covt<-covm%*%weLSm
covLS<-((t(weLSm)%*%covt)*252)^.5 # desv anualizada
reta1LSm<-as.matrix(reta1LS)
reta1LSf<-(t(weLSm)%*%reta1LSm)*252 #rend eserado del 
port[i,1]<-reta1LSf
port[i,2]<-covLS  
sharpe<-(reta1LSf-.05)/covLS  
port[i,3]<-covLS
port[i,4:(3+nt)]<-weLSm[,1]
}
```



```{r}
library(ggplot2)
port2<-as.data.frame(port)
ggplot(port2, aes(desv_est,rend))+ geom_point(alpha=.5, color="darkred")

```

```{r}
plot(port[,2],port[,1], xlab = "Riesgo", ylab="Rendimiento", cex = 0.2, pch = 20)

```

```{r}
plot(port[,2],port[,1],xlab ="Desv est",ylab="Rend del por")

```

The next code creates 1,000 simulations of weights. The code generates aleatory numbers, limiting to invest 100% of the wealth in the stocks in the 1rst tranche (high return). Also, it limits investing 10% of the wealth in the 3rd tranche (low return), but in a short position (you could change that % in line 15, replacing the 0.1 by the % you want). In Table 2, the code prints the returns, standard deviation, Sharpe of the portfolio, and the set of simulated weights. Finally, it orders the results based on the highest Sharpe index. The risk-free rate for this example is 5% .

Note: Regarding the random seed(), students often get nervous when they do not get the same result as the professor because np.random.rand generate aleatory numbers. Then it is useful to take out the # before random seed and get the same result. After everyone gets the same results, insert the # again.



# Appendix

Functions

An R function is created by using the keyword function. The basic syntax of an R function definition is as follows −

function_name <- function(arg_1, arg_2, ...) {
   Function body 
}


Create a function to print squares of numbers in sequence.

```{r}
myfun <- function(a) {
   for(i in 1:a) {
      b <- i^2
      print(b)
   }
}	
```



```{r}
myfun(5)
```

```{r}
# Create a function with arguments.
new.function <- function(a,b,c) {
   result <- a * b + c
   print(result)
}
new.function(5,3,11)
```





## Interactive Brokers API

In programación financiera we will cover automated trading, and we will use the plataform. 

https://www.interactivebrokers.com/en/home.php

```{r include=F}
library(IBrokers)
```

To explore the API:
https://tradersacademy.online/category/trading-courses/ibkr-api

You need to create a free account, download the desktop application and keep it open to do transactions and execute the functions in R. 

To to establish a connection the application server, function twsConnect 
```{r}
tws<-twsConnect(port=7497)
```

To verify if your connection is valid and verifying the connection time
```{r}
isConnected(tws)
twsConnectionTime(tws)
#twsDisconnect(tws)
```

The ticker to place an order (buy or sell), the twsEquity(symbol) has information of the ticker that could be changed, like the market where the ticker is traded.

```{r}
contract<-twsEquity("ADBE")
#contract
```

To get historical prices, even intra-day

```{r}
mrna<-reqHistoricalData(tws, Contract=contract,barSize = "1 min",duration = "1 w")
```


To place the order, in this case to buy. 
```{r}
orderId<-as.numeric(reqIds(tws))

# this is to create an order object
myorder<-twsOrder(orderId,orderType = "MKT",action = "BUY",totalQuantity = "50",transmit = TRUE)
```

To execute the order
```{r}

placeOrder(tws,contract,myorder)
# put the for printitng the html
```


###PART A: DATA LOADING AND SOURCES

```{r}
library (quantmod)

```

#Above command is to load the quantmod package; apackage which loads data from

# different internet sources: yahoo finance, googlefinance, Fed, oanand


#Under yahoo finance, there are stock market data:open-ing, closing, high, low values#Fromoananda, there are currency data just over 5 years,no high or low data###Get FTSE data from yahoo financegetSymbols(“^FTSE”, from=“2010-01-01”,to=“2015-06-15”)plot(FTSE)# To plot the series data FTSE# Codes for other stock markets (codes in brackets)#S&P 100 INDEX: (^OEX);S&P MID CAP 400 INDEX:(^MID), S&P 500:(^GSPC), VOLATILITY S&P 500:(^VIX),#Dow Jones Industrial Average:(^DJI), NASDAQComposite:(^IXIC), NYSE COMPOSITE (DJ):(^NYA),#FTSE 100:(^FTSE), DAX:(^GDAXI), CAC 40:(^FCHI),ESTX50 EUR:(^STOXX50E), Nikkei 225:(^N225),#HANG SENG INDEX:(^HSI), SSE Composite Index:(000001.SS), STI Index:(^STI)###OANANDA: getSymbols (“USD/EUR”, src=“oanda”,from=“2011-01-01”,to=“2015-06-10”)#Note in the case of oananda, only five years spanningtime period works

MLA, 8.ª edición (Modern Language Assoc.)
Indranarain Ramlall. Applied Technical Analysis for Advanced Learners and Practitioners. Emerald Group Publishing Limited, 2016.

APA, 7.ª edición (American Psychological Assoc.)
Indranarain Ramlall. (2016). Applied Technical Analysis for Advanced Learners and Practitioners. Emerald Group Publishing Limited.



```{r}
library (quantmod)


```

```{r}
getSymbols("BBY", from="2020-01-01", to="2021-11-17")

```

```{r}
plot(BBY)
```

```{r}
str(BBY)
```

```{r}
Ret.daily<- dailyReturn(BBY, subset=NULL, type="arithmetic", leading=TRUE)

Ret.weekly<- monthlyReturn(BBY, subset=NULL, type="arithmetic", leading=TRUE)


Ret.monthly<- monthlyReturn(BBY, subset=NULL, type="arithmetic", leading=TRUE)

Ret.quarterly<- quarterlyReturn(BBY, subset=NULL, type="arithmetic", leading=TRUE)

Ret.yearly<- yearlyReturn(BBY, subset=NULL, type="arithmetic", leading=TRUE)

Ret.allreturns<- allReturns(BBY, subset=NULL, type="arithmetic", leading=TRUE)

```

```{r}
ALLDATA=cbind(Ret.daily, Ret.weekly, Ret.monthly,Ret.quarterly, Ret.yearly, Ret.allreturns)

summary(ALLDATA, na.rm=T)
```

```{r}
library(TTR)
```


```{r}
chartSeries (BBY, theme="white")

addSMA(n=10, on=1, with.col=Cl, overlay=TRUE,col="brown")

addEMA (n = 10, wilder = FALSE, ratio = NULL, on = 1,with.col = Cl, overlay = TRUE, col = "blue") 

#addWMA (n = 10, wts = 1:n, on = 1, with.col = Cl,overlay = TRUE, col = "green")

addRSI(n=14, maType="EMA", wilder=TRUE)


```


```{r}
library(TTR)
```

```{r}
chartSeries (BBY, theme="white")

addSMA(n=10, on=1, with.col=Cl, overlay=TRUE,col="brown")

addEMA (n = 10, wilder = FALSE, ratio = NULL, on = 1,with.col = Cl, overlay = TRUE, col = "blue") 

#addWMA (n = 10, wts = 1:n, on = 1, with.col = Cl,overlay = TRUE, col = "green")

addRSI(n=14, maType="EMA", wilder=TRUE)

addMACD(fast=12, slow=26, signal=9, type="EMA", histogram=TRUE)

addBBands(n=20, sd=2, maType="SMA", draw="bands",on=-1)

chartSeries(BBY, theme="white", type="candlestick")

addADX(n=14, maType="EMA", wilder=TRUE)

addCCI(n=20, maType="SMA",c=0.015)

addROC(n=1, type=c("discrete","continuous"), col="red")

addSMI(n=13, slow=25, fast=2, signal=9,ma.type="EMA")

candleChart(BBY,multi.col=TRUE,theme="white")





```
```{r}
chartSeries (BBY, theme="white")


addZLEMA(n = 10, ratio=NULL, on = 1, with.col = Cl, overlay = TRUE, col = "red")

addSAR(accel = c(0.02, 0.2), col = "blue")

addWPR(n = 14)

addEVWMA(n = 10, on = 1, with.col = Cl, overlay = TRUE, col = "yellow")


addTRIX(n=20, signal=9, maType = "EMA", percent=TRUE)
```

```{r}
plotlyCandleStick <- function(symbol = "MSFT",
                              fillcolor = "#ff6666",
                              hollowcolor = "#39ac73",
                              linewidth = 4,
                              plotcolor = "#3E3E3E",
                              papercolor = "#1E2022",
                              fontcolor = "#B3A78C",
                              startdate = "2015-01-01"){
  
  # Get OHLC prices using quantmod
  prices <- getSymbols(symbol, auto.assign = F)
  prices <- prices[index(prices) >= startdate]
  
  # Convert to dataframe
  prices <- data.frame(time = index(prices),
                       open = as.numeric(prices[,1]),
                       high = as.numeric(prices[,2]),
                       low = as.numeric(prices[,3]),
                       close = as.numeric(prices[,4]),
                       volume = as.numeric(prices[,5]))
  
  # Create line segments for high and low prices
  plot.base <- data.frame()
  plot.hollow <- data.frame()
  plot.filled <- data.frame()
  
  for(i in 1:nrow(prices)){
    x <- prices[i, ]
    
    # For high / low
    mat <- rbind(c(x[1], x[3]), 
                 c(x[1], x[4]),
                 c(NA, NA))
    
    plot.base <- rbind(plot.base, mat)
    
    # For open / close
    if(x[2] > x[5]){
      mat <- rbind(c(x[1], x[2]), 
                   c(x[1], x[5]),
                   c(NA, NA))
      
      plot.filled <- rbind(plot.filled, mat)
    }else{
      mat <- rbind(c(x[1], x[2]), 
                   c(x[1], x[5]),
                   c(NA, NA))
      
      plot.hollow <- rbind(plot.hollow, mat)
    }
  }  
  
  colnames(plot.base) <- colnames(plot.hollow) <- colnames(plot.filled) <- c("x", "y")
  plot.base$x <- as.Date(as.numeric(plot.base$x))
  plot.hollow$x <- as.Date(as.numeric(plot.hollow$x))
  plot.filled$x <- as.Date(as.numeric(plot.filled$x))
  
  hovertxt <- paste("Date: ", round(prices$time,2), "<br>",
                    "High: ", round(prices$high,2),"<br>",
                    "Low: ", round(prices$low,2),"<br>",
                    "Open: ", round(prices$open,2),"<br>",
                    "Close: ", round(prices$close,2))
  
  
  # Base plot for High / Low prices
  p <- plot_ly(plot.base, x = x, y = y, mode = "lines", 
               marker = list(color = '#9b9797'),
               line = list(width = 1),
               showlegend = F,
               hoverinfo = "none")
  
  # Trace for when open price > close price
  p <- add_trace(p, data = plot.filled, x = x, y = y, mode = "lines", 
                 marker = list(color = fillcolor),
                 line = list(width = linewidth),
                 showlegend = F,
                 hoverinfo = "none")
  
  # Trace for when open price < close price
  p <- add_trace(p, data = plot.hollow, x = x, y = y, mode = "lines", 
                 marker = list(color = hollowcolor),
                 line = list(width = linewidth),
                 showlegend = F,
                 hoverinfo = "none")
  
  # Trace for volume
  p <- add_trace(p, data = prices, x = time, y = volume/1e6, type = "bar",
                 marker = list(color = "#ff9933"),
                 showlegend = F,
                 hoverinfo = "x+y",
                 yaxis = "y2")
  
  # Trace for hover info
  p <- add_trace(p, data = prices, x = time, y = high, opacity = 0, hoverinfo = "text",
                 text = hovertxt, showlegend = F)
  
  # Layout options
  p <- layout(p, xaxis = list(title = "", showgrid = F, 
                              tickformat = "%b-%Y", 
                              tickfont = list(color = fontcolor),
                              rangeselector = list(
                                x = 0.85, y = 0.97, bgcolor = "fontcolor",
                                buttons = list(
                                  list(
                                    count = 3, 
                                    label = "3 mo", 
                                    step = "month",
                                    stepmode = "backward"),
                                  list(
                                    count = 6, 
                                    label = "6 mo", 
                                    step = "month",
                                    stepmode = "backward"),
                                  list(
                                    count = 1, 
                                    label = "1 yr", 
                                    step = "year",
                                    stepmode = "backward"),
                                  list(
                                    count = 1, 
                                    label = "YTD", 
                                    step = "year",
                                    stepmode = "todate"),
                                  list(step = "all")))),
              
              yaxis = list(title = "Price", gridcolor = "#8c8c8c",
                           tickfont = list(color = fontcolor), 
                           titlefont = list(color = fontcolor),
                           domain = c(0.30, 0.95)),
              
              yaxis2 = list(gridcolor = "#8c8c8c",
                            tickfont = list(color = fontcolor), 
                            titlefont = list(color = fontcolor),
                            side = "right", 
                            domain = c(0, 0.2)),
              
              paper_bgcolor = papercolor,
              plot_bgcolor = plotcolor,
              margin = list(r = 50, t = 50),
              
              annotations = list(
                list(x = 0.02, y = 0.25, text = "Volume(mil)", ax = 0, ay = 0, align = "left",
                     xref = "paper", yref = "paper", xanchor = "left", yanchor = "top",
                     font = list(size = 20, color = fontcolor)),
                
                list(x = 0, y = 1, text = symbol, ax = 0, ay = 0, align = "left",
                     xref = "paper", yref = "paper", xanchor = "left", yanchor = "top",
                     font = list(size = 20, color = fontcolor)), 
                
                list(x = 0.1, y = 1, 
                     text = paste("Start: ", format(min(prices$time), "%b-%Y"),
                                  "<br>End: ", format(max(prices$time), "%b-%Y")),
                     ax = 0, ay = 0, align = "left",
                     xref = "paper", yref = "paper", xanchor = "left", yanchor = "top",
                     font = list(size = 10, color = fontcolor))
              ))
  
  return(p)
}
library(plotly)
library(quantmod)


```

```{r}
plotlyCandleStick("TSLA")

```


